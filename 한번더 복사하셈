"""
pybullet_slip_gui_fixed.py

Tkinter + matplotlib front-end for running PyBullet slip simulations (DIRECT mode).
This script has been tightened to avoid common threading/queue/pybullet mistakes.

Requirements:
    pip install pybullet matplotlib
"""

import threading
import time
import math
import random
import queue
import tkinter as tk
from tkinter import ttk, messagebox

# IMPORT MATPLOTLIB WITH TK BACKEND BEFORE pyplot
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

import pybullet as p
import pybullet_data

# ---------------- Simulation parameters ----------------
MU_SAFE = 0.42             # safety threshold
BASE_PROB = 0.6            # base slip probability coefficient
V_REF = 1.0                # reference speed (m/s)
WET_FACTOR = 1.8           # multiplier when wet; simple model

TILE_SIZE = 1.0
GRID_W = 4
GRID_H = 3

SIM_STEP = 1. / 240.
SIM_DURATION = 5.0  # seconds per run (짧게 설정해 빠르게 반복 가능)

# Tile types and representative mu (DCOF-like)
TILE_TYPES = {
    "polished_marble": 0.28,
    "glazed_porcelain": 0.35,
    "matte_porcelain": 0.48,
    "quarry_tile": 0.60,
    "terracotta": 0.55,
    "vinyl": 0.38,
    "concrete_wet": 0.20
}
TILE_ORDER = list(TILE_TYPES.keys())

# ---------------- Helper functions for slip model ----------------
def slip_risk_from_mu(mu: float) -> float:
    return max(0.0, (MU_SAFE - mu) / MU_SAFE)

def compute_p_slip(mu: float, tangential_speed: float, wet: bool=False) -> float:
    R = slip_risk_from_mu(mu)
    speed_factor = min(2.0, (tangential_speed / V_REF) if V_REF > 0 else 0.0)
    wet_factor_local = WET_FACTOR if wet else 1.0
    p_slip = BASE_PROB * R * speed_factor * wet_factor_local
    return max(0.0, min(1.0, p_slip))

# ---------------- Simulation runner ----------------
class SlipSimulator:
    def __init__(self, grid_w=GRID_W, grid_h=GRID_H, tile_types=TILE_TYPES):
        self.grid_w = grid_w
        self.grid_h = grid_h
        self.tile_types = tile_types
        self.tile_order = list(tile_types.keys())

        # Stats
        self.total_runs = 0
        self.slip_counts = {k: 0 for k in self.tile_order}

        # Thread-safe queue for reporting run results to GUI thread
        self.result_queue = queue.Queue()

        # Protect stats if accessed from multiple threads
        self._lock = threading.Lock()

    def reset_stats(self):
        with self._lock:
            self.total_runs = 0
            for k in self.slip_counts:
                self.slip_counts[k] = 0

    def get_stats_snapshot(self):
        with self._lock:
            return self.total_runs, dict(self.slip_counts)

    def _create_random_tile_layout(self, start_x, start_y):
        """Return list of (body_id, name, mu, x, y) for created tiles."""
        types_list = [random.choice(self.tile_order) for _ in range(self.grid_w * self.grid_h)]
        tile_infos = []
        for i, name in enumerate(types_list):
            mu = self.tile_types[name]
            x = start_x + (i % self.grid_w + 0.5) * TILE_SIZE
            y = start_y + (i // self.grid_w + 0.5) * TILE_SIZE
            col = p.createCollisionShape(p.GEOM_BOX, halfExtents=[TILE_SIZE/2, TILE_SIZE/2, 0.01])
            vis = p.createVisualShape(p.GEOM_BOX, halfExtents=[TILE_SIZE/2, TILE_SIZE/2, 0.01],
                                      rgbaColor=[random.random(), random.random(), random.random(), 1])
            tid = p.createMultiBody(baseMass=0, baseCollisionShapeIndex=col, baseVisualShapeIndex=vis,
                                     basePosition=[x, y, -0.01])
            # lateralFriction uses a small positive minimum
            p.changeDynamics(tid, -1, lateralFriction=max(0.01, mu))
            tile_infos.append((tid, name, mu, x, y))
        return tile_infos

    def run_single(self, seed=None):
        """Run one simulation. Puts a result dict into result_queue when done."""
        if seed is not None:
            random.seed(seed)

        physics_client = p.connect(p.DIRECT)
        try:
            p.setAdditionalSearchPath(pybullet_data.getDataPath())
            p.resetSimulation()
            p.setGravity(0, 0, -9.81)
            p.setTimeStep(SIM_STEP)

            # ground
            _plane = p.loadURDF("plane.urdf")

            # tiles
            start_x = - (self.grid_w * TILE_SIZE) / 2.0
            start_y = - (self.grid_h * TILE_SIZE) / 2.0
            tile_infos = self._create_random_tile_layout(start_x, start_y)

            # person
            collision = p.createCollisionShape(p.GEOM_CAPSULE, radius=0.2, height=0.6)
            vis = p.createVisualShape(p.GEOM_CAPSULE, radius=0.2, length=0.6, rgbaColor=[0.2, 0.4, 0.8, 1])
            person = p.createMultiBody(baseMass=75.0, baseCollisionShapeIndex=collision, baseVisualShapeIndex=vis,
                                       basePosition=[start_x + TILE_SIZE*0.5, 0, 0.8])
            p.resetBaseVelocity(person, linearVelocity=[1.5, 0, 0])

            # run
            elapsed = 0.0
            slips_this_run = {name: 0 for name in self.tile_order}

            while elapsed < SIM_DURATION:
                contacts = p.getContactPoints(bodyA=person)
                for c in contacts:
                    other = c[2]
                    for tid, name, mu, tx, ty in tile_infos:
                        if tid != other:
                            continue
                        lin_vel, _ = p.getBaseVelocity(person)
                        tangential_speed = math.hypot(lin_vel[0], lin_vel[1])
                        wet = ('wet' in name)
                        p_slip = compute_p_slip(mu, tangential_speed, wet=wet)
                        if random.random() < p_slip:
                            # apply an impulse to exaggerate slip (simple approach)
                            slip_impulse = [lin_vel[0] * 20.0, lin_vel[1] * 20.0, 0]
                            p.applyExternalImpulse(person, -1, slip_impulse, c[5], p.WORLD_FRAME)
                            slips_this_run[name] += 1
                p.stepSimulation()
                # small sleep to yield CPU; keeps background thread responsive
                time.sleep(SIM_STEP)
                elapsed += SIM_STEP

            # update global stats under lock
            with self._lock:
                self.total_runs += 1
                for name, cnt in slips_this_run.items():
                    self.slip_counts[name] += cnt

            # send result summary to GUI
            self.result_queue.put(("run_result", slips_this_run))
        except Exception as e:
            # report error
            self.result_queue.put(("error", str(e)))
        finally:
            # always disconnect the physics client we opened
            try:
                p.disconnect(physics_client)
            except Exception:
                pass

# ---------------- GUI ----------------
class SlipGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("PyBullet Slip Simulator (fixed)")

        self.sim = SlipSimulator()

        # layout frames
        left = ttk.Frame(root, padding=6)
        left.grid(row=0, column=0, sticky="ns")
        right = ttk.Frame(root, padding=6)
        right.grid(row=0, column=1, sticky="nsew")

        # controls
        ttk.Label(left, text="Controls").grid(row=0, column=0, pady=(0,6))
        self.run_btn = ttk.Button(left, text="Run (1)", command=self.run_once)
        self.run_btn.grid(row=1, column=0, sticky="ew", pady=2)

        repfrm = ttk.Frame(left)
        repfrm.grid(row=2, column=0, pady=2)
        ttk.Label(repfrm, text="Repeat N:").grid(row=0, column=0)
        self.repeat_var = tk.IntVar(value=5)
        self.repeat_entry = ttk.Entry(repfrm, textvariable=self.repeat_var, width=6)
        self.repeat_entry.grid(row=0, column=1, padx=(4,0))
        self.repeat_btn = ttk.Button(left, text="Repeat", command=self.run_repeat)
        self.repeat_btn.grid(row=3, column=0, sticky="ew", pady=2)

        self.reset_btn = ttk.Button(left, text="Reset Stats", command=self.reset_stats)
        self.reset_btn.grid(row=4, column=0, pady=8, sticky="ew")

        self.status_label = ttk.Label(left, text="Idle", foreground="blue")
        self.status_label.grid(row=5, column=0, pady=(8,0))

        # Matplotlib figure
        fig = Figure(figsize=(8,4))
        self.ax = fig.add_subplot(111)
        self.ax.set_title("Slip counts per tile type")
        self.canvas = FigureCanvasTkAgg(fig, master=right)
        self.canvas.get_tk_widget().pack(fill="both", expand=True)

        # local control flags
        self._running = False
        self._worker_thread = None

        # start periodic GUI update
        self.root.after(200, self._periodic_update)
        # initial draw
        self._draw_chart()

    def _draw_chart(self):
        total_runs, counts = self.sim.get_stats_snapshot()
        names = TILE_ORDER
        values = [counts.get(n, 0) for n in names]
        self.ax.clear()
        self.ax.bar(range(len(names)), values)
        self.ax.set_xticks(range(len(names)))
        self.ax.set_xticklabels(names, rotation=30, ha="right")
        self.ax.set_ylabel("Slip count (cumulative)")
        self.ax.set_title(f"Slip counts per tile type (runs={total_runs})")
        self.canvas.draw()

    def _set_controls_enabled(self, enabled: bool):
        state = "normal" if enabled else "disabled"
        self.run_btn.config(state=state)
        self.repeat_btn.config(state=state)
        self.reset_btn.config(state=state)
        self.repeat_entry.config(state=state)

    def run_once(self):
        if self._running:
            return
        self._start_worker(1)

    def run_repeat(self):
        if self._running:
            return
        try:
            n = int(self.repeat_var.get())
            if n <= 0:
                raise ValueError
        except Exception:
            messagebox.showerror("Invalid", "Repeat N must be a positive integer")
            return
        self._start_worker(n)

    def reset_stats(self):
        if self._running:
            messagebox.showinfo("Wait", "Can't reset while running")
            return
        self.sim.reset_stats()
        self._draw_chart()
        self.status_label.config(text="Stats reset", foreground="blue")

    def _start_worker(self, n_runs: int):
        # Worker runs sequential runs in background
        self._running = True
        self._set_controls_enabled(False)
        self.status_label.config(text=f"Running {n_runs} run(s)...", foreground="green")

        def worker():
            try:
                for i in range(n_runs):
                    # run single sim
                    self.sim.run_single()
                    # allow a tiny pause
                    time.sleep(0.02)
                # signal worker done
                self.sim.result_queue.put(("done", None))
            except Exception as e:
                self.sim.result_queue.put(("error", str(e)))

        self._worker_thread = threading.Thread(target=worker, daemon=True)
        self._worker_thread.start()

    def _periodic_update(self):
        """Process messages from simulator and update UI."""
        any_update = False
        while not self.sim.result_queue.empty():
            any_update = True
            try:
                tag, payload = self.sim.result_queue.get_nowait()
            except queue.Empty:
                break
            if tag == "run_result":
                # payload: slips_this_run dict
                summary_items = [f"{k}:{v}" for k, v in payload.items() if v > 0]
                summary = ", ".join(summary_items) if summary_items else "no slips this run"
                self.status_label.config(text=f"Last run: {summary}", foreground="black")
            elif tag == "error":
                self.status_label.config(text=f"Error: {payload}", foreground="red")
                # stop run if error
                self._running = False
                self._set_controls_enabled(True)
            elif tag == "done":
                # worker finished all requested runs
                self._running = False
                self._set_controls_enabled(True)
                self.status_label.config(text="Idle", foreground="blue")
            # ignore unknown tags

        if any_update:
            self._draw_chart()

        # schedule next check
        self.root.after(200, self._periodic_update)

# ---------------- Main entry ----------------
def main():
    root = tk.Tk()
    app = SlipGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
